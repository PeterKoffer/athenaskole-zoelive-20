import curriculumStepsData from '../../public/data/curriculum-steps.json'; // Adjusted path
import { CurriculumStep, Curriculum } from '@/types/curriculum';
import { LearningAtom, DailyUniverse } from '@/types/learning';
import { mockUserProgressService } from './mockUserProgressService';
import DynamicNarrativeService, { LearningObjectiveInput } from './DynamicNarrativeService';

interface DailyUniverseParams {
  userId: string;
  studentAge: number; // Used to infer a general grade level if no specific current step is found
  // theme?: string; // Future: Allow theme selection or make it dynamic
}

const MAX_ATOMS_PER_DAY = 8;
const MIN_ATOMS_PER_DAY = 5; // Ensure at least some content
const SUBJECT_DIVERSITY_TARGET = 3; // Aim for at least this many different subjects

// List of available theme names. The actual content will be generated by DynamicNarrativeService.
const AVAILABLE_THEME_NAMES = [
  'Galactic Research Mission',
  'Time Detective Agency',
  'Guardian of the Living Forest',
  'Young Inventor\'s Workshop',
  'Mysteries of the Deep Sea'
];

export class DailyUniverseGenerator {
  private curriculumSteps: CurriculumStep[] = curriculumStepsData as CurriculumStep[];

  public async generateUniverse(params: DailyUniverseParams): Promise<DailyUniverse | null> {
    const { userId, studentAge } = params;
    console.log(`[DailyUniverseGenerator] Generating universe for userId: ${userId}, age: ${studentAge}`);

    const userProgress = await mockUserProgressService.getUserProgress(userId);

    // 1. Determine student's current learning focus (active steps)
    let activeStepNumbers: number[] = [];
    const allStepsSorted = [...this.curriculumSteps].sort((a, b) => a.stepNumber - b.stepNumber);

    let primaryActiveStepFound = false;
    for (const step of allStepsSorted) {
      const stepProgress = userProgress.find(sp => sp.stepId === step.id);
      if (!stepProgress || !stepProgress.isCompleted) {
        activeStepNumbers.push(step.stepNumber);
        primaryActiveStepFound = true;
        if (activeStepNumbers.length >= 2) break; // Consider current and next step
      }
    }

    if (!primaryActiveStepFound && allStepsSorted.length > 0) { // All steps completed or no progress, start from beginning or an age-appropriate step
      const inferredGradeLevel = Math.max(0, studentAge - 6); // K=0, G1=1 etc.
      const targetStep = allStepsSorted.find(s => s.stepNumber === inferredGradeLevel + 1) || allStepsSorted[0];
      activeStepNumbers = [targetStep.stepNumber];
      if (targetStep.stepNumber < allStepsSorted.length) {
        activeStepNumbers.push(targetStep.stepNumber + 1);
      }
    }
     if (activeStepNumbers.length === 0 && allStepsSorted.length > 0) { // Still nothing, maybe user has no progress records at all
        activeStepNumbers.push(allStepsSorted[0].stepNumber); // Default to first step
    }


    console.log(`[DailyUniverseGenerator] Active step numbers for focus: ${activeStepNumbers.join(', ')}`);

    // 2. Gather potential objectives from these active steps
    let potentialObjectives: Curriculum[] = [];
    activeStepNumbers.forEach(stepNum => {
      const step = this.curriculumSteps.find(s => s.stepNumber === stepNum);
      if (step) {
        potentialObjectives.push(...step.curriculums);
      }
    });

    console.log(`[DailyUniverseGenerator] Found ${potentialObjectives.length} potential objectives initially.`);

    // 3. Filter out completed objectives
    const uncompletedObjectives = potentialObjectives.filter(obj => {
      const stepProg = userProgress.find(sp => sp.stepId === obj.stepId);
      return !stepProg || !stepProg.curriculumProgress[obj.id];
    });
    console.log(`[DailyUniverseGenerator] Found ${uncompletedObjectives.length} uncompleted objectives.`);

    // 4. Prioritize & Select Objectives (Simplified for now, more complex weighting can be added)
    // For this iteration, we'll shuffle uncompleted and try to get subject diversity
    let selectedObjectives: Curriculum[] = [];
    const shuffledUncompleted = [...uncompletedObjectives].sort(() => 0.5 - Math.random());

    const objectivesBySubject: Record<string, Curriculum[]> = {};
    shuffledUncompleted.forEach(obj => {
      if (!objectivesBySubject[obj.subject]) {
        objectivesBySubject[obj.subject] = [];
      }
      objectivesBySubject[obj.subject].push(obj);
    });

    // Try to pick to ensure subject diversity first, then fill up
    const subjectsPresent = Object.keys(objectivesBySubject);
    let atomCount = 0;

    for (let i = 0; i < SUBJECT_DIVERSITY_TARGET && i < subjectsPresent.length; i++) {
      const subjectKey = subjectsPresent[i];
      const objFromSubject = objectivesBySubject[subjectKey].shift(); // Get one
      if (objFromSubject) {
        selectedObjectives.push(objFromSubject);
        atomCount++;
      }
    }

    // Fill remaining slots from shuffled list, avoiding duplicates
    for (const obj of shuffledUncompleted) {
      if (atomCount >= MAX_ATOMS_PER_DAY) break;
      if (!selectedObjectives.find(so => so.id === obj.id)) {
        selectedObjectives.push(obj);
        atomCount++;
      }
    }

    // If not enough, try adding some recently completed for revision (very basic)
    if (selectedObjectives.length < MIN_ATOMS_PER_DAY) {
        const completedObjectives = potentialObjectives.filter(obj => {
            const stepProg = userProgress.find(sp => sp.stepId === obj.stepId);
            return stepProg && stepProg.curriculumProgress[obj.id];
        }).sort(() => 0.5 - Math.random());

        for (const obj of completedObjectives) {
            if (selectedObjectives.length >= MIN_ATOMS_PER_DAY) break;
            if (!selectedObjectives.find(so => so.id === obj.id)) {
                selectedObjectives.push(obj); // Mark for revision later
            }
        }
    }


    if (selectedObjectives.length === 0) {
      console.log("[DailyUniverseGenerator] No objectives selected. Universe generation failed or student has completed all available content in focus.");
      // Fallback: select a few from the very first step if truly nothing.
      const firstStep = allStepsSorted[0];
      if(firstStep && firstStep.curriculums.length > 0){
        selectedObjectives = firstStep.curriculums.slice(0, Math.min(MIN_ATOMS_PER_DAY, firstStep.curriculums.length));
        console.log(`[DailyUniverseGenerator] Fallback: Selected ${selectedObjectives.length} objectives from the first step.`);
      } else {
        return null; // Cannot generate a universe
      }
    }

    console.log(`[DailyUniverseGenerator] Selected ${selectedObjectives.length} objectives for the universe.`);

    // 5. Generate Dynamic Narrative Components
    const currentThemeName = AVAILABLE_THEME_NAMES[Math.floor(Math.random() * AVAILABLE_THEME_NAMES.length)];

    const learningObjectiveInputs: LearningObjectiveInput[] = selectedObjectives.map(obj => ({
      objectiveId: obj.id,
      objectiveTitle: obj.title,
      subject: obj.subject,
      estimatedMinutes: obj.duration
    }));

    const narrativeComponents = await DynamicNarrativeService.generateNarrative(
      currentThemeName,
      studentAge,
      learningObjectiveInputs,
      selectedObjectives.length
    );

    if (narrativeComponents.error) {
      console.error(`[DailyUniverseGenerator] Error from DynamicNarrativeService: ${narrativeComponents.error}. Using fallback narrative elements if available.`);
      // The service itself returns fallback data, so we just use what's given.
    }
    if (narrativeComponents.fallbackUsed) {
        console.warn(`[DailyUniverseGenerator] Dynamic narrative generation used fallback templates for theme: ${currentThemeName}`);
    }


    // 6. Create LearningAtoms using dynamic narrative contexts
    const learningAtoms: LearningAtom[] = selectedObjectives.map((obj, index) => {
      const atomNarrative = narrativeComponents.atomContexts.find(ac => ac.objectiveId === obj.id);
      const narrativeContext = atomNarrative ? atomNarrative.narrativeContext : `Engage with: ${obj.title}`; // Fallback if specific context is missing

      // Simple type/interaction assignment (can be more sophisticated)
      let type: LearningAtom['type'] = 'challenge';
      let interactionType: LearningAtom['interactionType'] = 'puzzle';
      if (obj.subject.toLowerCase().includes('science')) {
        type = 'exploration'; interactionType = 'experiment';
      } else if (obj.subject.toLowerCase().includes('english') || obj.subject.toLowerCase().includes('dansk') || obj.subject.toLowerCase().includes('language')) {
        type = 'creation'; interactionType = 'story';
      } else if (obj.subject.toLowerCase().includes('history')) {
        type = 'discovery'; interactionType = 'creative';
      }


      return {
        id: `atom-${obj.id}-${Date.now()}-${index}`, // Ensure unique atom ID
        type,
        subject: obj.subject,
        curriculumObjectiveId: obj.id,
        curriculumObjectiveTitle: obj.title,
        narrativeContext: narrativeContext,
        estimatedMinutes: obj.duration || 15,
        interactionType,
        content: {
          title: obj.title,
          description: obj.description,
          data: { standards: obj.standards }
        },
      };
    });

    const totalMinutes = learningAtoms.reduce((sum, atom) => sum + atom.estimatedMinutes, 0);

    const universe: DailyUniverse = {
      userId,
      theme: currentThemeName, // Use the theme name passed to/used by the service
      storylineIntro: narrativeComponents.storylineIntro,
      learningAtoms,
      storylineOutro: narrativeComponents.storylineOutro,
      estimatedTotalMinutes: totalMinutes,
      dateGenerated: new Date().toISOString(),
    };

    console.log(`[DailyUniverseGenerator] Generated universe with ${universe.learningAtoms.length} atoms. Theme: ${universe.theme}. Est. Time: ${totalMinutes}m. Fallback used: ${!!narrativeComponents.fallbackUsed}`);
    return universe;
  }
}

export default new DailyUniverseGenerator();
