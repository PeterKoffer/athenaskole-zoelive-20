import { supabase } from "@/integrations/supabase/client";
import { UniversePacks } from "@/content/universe.catalog";
import type { UniversePack } from "@/content/types";

export interface AdventureUniverse {
  id: string;
  title: string;
  subject: string;
  grade_level: string;
  description: string;
  goals: any;
  metadata: any;
  image_url?: string;
  slug: string;
  category?: string;
  imagePrompt?: string;
}

export interface AdventureContent {
  id: string;
  universe_id: string;
  summary: string;
  objectives: string[];
  activities: any;
}

export interface AdventureProgress {
  id: string;
  student_id: string;
  universe_id: string;
  completed_at: Date;
  is_recap: boolean;
  performance_score?: number;
}

export interface AdventureSelectionCriteria {
  userId: string;
  gradeLevel?: string;
  subject?: string;
  preferences?: {
    curriculum?: string;
    difficulty?: string;
    learningStyle?: string;
    interests?: string[];
  };
}

export class AdventureService {
  
  /**
   * Generate magical, age-appropriate backstory to hook students into the adventure
   */
  private static generateMagicalBackstory(pack: UniversePack, gradeLevel: string): string {
    const gradeInt = gradeLevel === "K-2" ? 1 : 
                     gradeLevel === "3-5" ? 4 : 
                     gradeLevel === "6-8" ? 6 : 
                     gradeLevel === "9-10" ? 9 : 11;

    const isYoung = gradeInt <= 5; // K-5 gets more magical language
    const isMiddle = gradeInt >= 6 && gradeInt <= 8; // 6-8 gets adventure language  
    const isOlder = gradeInt >= 9; // 9+ gets challenge/discovery language

    const adventureTitle = pack.title;
    const subject = pack.subjectHint;
    const category = pack.category.toLowerCase();

    // Create backstory templates based on age and adventure type
    if (isYoung) {
      const youngStories = [
        `üåü En dag n√•r du g√•r forbi en gammel, glemte ${adventureTitle.toLowerCase()}, begynder den pludselig at skinne magisk! Du opdager, at den gemmer p√• fantastiske hemmeligheder, der kan hj√¶lpe dig med at l√¶re om ${subject}. Hvad mon der sker, hvis du tager mod udfordringen?`,
        `‚ú® I din baghave finder du en mystisk bog om ${adventureTitle}. N√•r du √•bner den, springer ordene ud af siderne og inviterer dig med p√• det mest sp√¶ndende eventyr! Er du klar til at springe ind i ${subject}-verdenen?`,
        `üé™ Den gamle cirkusvogn p√• hj√∏rnet har altid v√¶ret tom - indtil i dag! Pludselig summer den af aktivitet med ${adventureTitle}, og du f√•r chancen for at blive dagens helt ved at mestre ${subject} p√• en helt ny m√•de!`
      ];
      return youngStories[Math.floor(Math.random() * youngStories.length)];
    }

    if (isMiddle) {
      const middleStories = [
        `üöÄ Du st√∏der p√• en g√•defuld ${adventureTitle.toLowerCase()}, som ser helt almindelig ud - men hold da op! Den gemmer p√• utrolige muligheder for at udforske ${subject} p√• en m√•de, du aldrig har pr√∏vet f√∏r. T√∏r du tage udfordringen op?`,
        `üïµÔ∏è En m√¶rkelig opdagelse venter dig: ${adventureTitle} har brug for din hj√¶lp! Med dine ${subject}-f√¶rdigheder som v√•ben, kan du l√∏se mysteriet og redde dagen. Hvad venter der p√• den anden side af eventyret?`,
        `‚ö° Forestil dig at ${adventureTitle.toLowerCase()} pludselig bliver dit ansvar. Du har chancen for at vise, hvad du kan med ${subject}, men der er b√•de udfordringer og fantastiske overraskelser forude. Er du klar til at bevise dit v√¶rd?`
      ];
      return middleStories[Math.floor(Math.random() * middleStories.length)];
    }

    // Older students (9+)
    const olderStories = [
      `üéØ En uventet mulighed dukker op: du f√•r chancen for at tage kontrol over ${adventureTitle} og bevise dine ${subject}-f√¶rdigheder i praksis. Det handler ikke bare om teori - det er din chance for at skabe noget betydningsfuldt og vise verden, hvad du kan!`,
      `üåç ${adventureTitle} st√•r over for en kritisk udfordring, og der er brug for nogen med dine ${subject}-talenter til at finde l√∏sningen. Dette er mere end bare en opgave - det er din mulighed for at g√∏re en reel forskel og l√¶re utroligt meget undervejs.`,
      `üí° Du opdager en fascinerende situation omkring ${adventureTitle}, der kr√¶ver kreativ probleml√∏sning og solid ${subject}-viden. Dette projekt kan √•bne d√∏re til ny erkendelse og give dig f√¶rdigheder, du kan bruge resten af livet!`
    ];
    return olderStories[Math.floor(Math.random() * olderStories.length)];
  }

  /**
   * Convert UniversePack to AdventureUniverse format
   */
  private static universePackToAdventure(pack: UniversePack, gradeLevel: string = "6-8"): AdventureUniverse {
    // Convert grade level to integer for image system
    const gradeInt = gradeLevel === "K-2" ? 1 : 
                     gradeLevel === "3-5" ? 4 : 
                     gradeLevel === "6-8" ? 6 : 
                     gradeLevel === "9-10" ? 9 : 11;
    
    // Generate magical backstory to hook the student
    const magicalBackstory = this.generateMagicalBackstory(pack, gradeLevel);
    
    return {
      id: pack.id,
      title: pack.title,
      subject: pack.subjectHint,
      grade_level: gradeLevel,
      description: magicalBackstory,
      goals: pack.beats[gradeLevel as keyof typeof pack.beats] || pack.beats["6-8"],
      metadata: {
        category: pack.category,
        tags: pack.tags,
        crossSubjects: pack.crossSubjects,
        beats: pack.beats,
        gradeInt: gradeInt
      },
      slug: pack.id,
      category: pack.category,
      imagePrompt: pack.imagePrompt,
      // Use the universe image system path format
      image_url: `universe-images/${pack.id}/${gradeInt}/cover.webp`
    };
  }

  /**
   * Get today's adventure for the student using the curated catalog
   * Ensures they never see the same universe twice (unless recap)
   */
  static async getTodaysAdventure(criteria: AdventureSelectionCriteria): Promise<{
    universe: AdventureUniverse;
    content?: AdventureContent;
    isRecap: boolean;
  }> {
    try {
      // Get completed adventures from database
      const { data: completedAdventures } = await supabase
        .from('student_adventures')
        .select('universe_id, is_recap')
        .eq('student_id', criteria.userId);

      const completedUniverseIds = completedAdventures
        ?.filter(a => !a.is_recap)
        .map(a => a.universe_id) || [];

      // Filter available universes from catalog
      const availableUniverses = UniversePacks.filter(pack => 
        !completedUniverseIds.includes(pack.id)
      );

      let selectedPack: UniversePack;
      let isRecap = false;

      if (availableUniverses.length === 0) {
        // No new universes available - time for a recap!
        if (completedUniverseIds.length === 0) {
          // First time user - select random universe
          selectedPack = UniversePacks[Math.floor(Math.random() * UniversePacks.length)];
        } else {
          // Select a random completed universe for recap
          const completedPacks = UniversePacks.filter(pack => 
            completedUniverseIds.includes(pack.id)
          );
          selectedPack = completedPacks[Math.floor(Math.random() * completedPacks.length)];
          isRecap = true;
        }
      } else {
        // Filter by subject preference if provided
        let filteredUniverses = availableUniverses;
        if (criteria.subject) {
          const subjectMatches = availableUniverses.filter(pack => 
            pack.subjectHint.toLowerCase().includes(criteria.subject!.toLowerCase()) ||
            pack.crossSubjects.some(s => s.toLowerCase().includes(criteria.subject!.toLowerCase()))
          );
          if (subjectMatches.length > 0) {
            filteredUniverses = subjectMatches;
          }
        }

        // Select random universe
        selectedPack = filteredUniverses[Math.floor(Math.random() * filteredUniverses.length)];
      }

      // Convert to AdventureUniverse format
      const selectedUniverse = this.universePackToAdventure(selectedPack, criteria.gradeLevel || "6-8");

      // Generate content based on the universe pack
      const content: AdventureContent = {
        id: `content-${selectedPack.id}`,
        universe_id: selectedPack.id,
        summary: `Nu hvor du er tr√•dt ind i eventyret, er det tid til at dykke dybt ned i ${selectedPack.title}! Denne ${selectedPack.category.toLowerCase()} oplevelse vil udfordre dig til at t√¶nke kreativt, l√∏se problemer fra den virkelige verden, og opdage nye m√•der at anvende din viden p√•.`,
        objectives: [
          `Forst√• n√∏glekoncepterne bag ${selectedPack.title}`,
          `Anvend probleml√∏sningsevner i en ${selectedPack.category.toLowerCase()} sammenh√¶ng`,
          `Skab noget konkret relateret til ${selectedPack.title}`,
          `Reflekt√©r over l√¶ringsoplevelsen og pr√¶sent√©r dine fund`
        ],
        activities: this.generateActivitiesFromBeats(selectedPack, criteria.gradeLevel || "6-8")
      };

      return {
        universe: selectedUniverse,
        content,
        isRecap
      };

    } catch (error) {
      console.error('Error in getTodaysAdventure:', error);
      throw error;
    }
  }

  /**
   * Generate activities from universe pack beats
   */
  private static generateActivitiesFromBeats(pack: UniversePack, gradeLevel: string) {
    const beats = pack.beats[gradeLevel as keyof typeof pack.beats] || pack.beats["6-8"];
    
    return beats.map((beat, index) => ({
      id: `activity-${index + 1}`,
      title: beat.title,
      type: beat.kind,
      instructions: this.generateInstructionsForBeat(beat, pack),
      estimatedMinutes: beat.minutes[gradeLevel as keyof typeof beat.minutes] || beat.minutes["6-8"],
      props: beat.props,
      tags: beat.tags
    }));
  }

  /**
   * Generate engaging, age-appropriate instructions for adventure activities
   */
  private static generateInstructionsForBeat(beat: any, pack: UniversePack): string {
    const adventureTitle = pack.title;
    
    switch (beat.kind) {
      case 'visual_hook':
        return `üé¨ Dive into the exciting world of ${adventureTitle}! Imagine the thrilling setting, meet the key players, and discover the amazing challenges you'll face on your adventure!`;
      
      case 'make_something':
        return `üõ†Ô∏è Unleash your creativity! Design and build something incredible that will be your secret weapon for conquering the ${adventureTitle} mission. Will it be a clever plan, cool design, or awesome prototype?`;
      
      case 'investigate':
        return `üïµÔ∏è Become an expert detective! Research and uncover the vital clues you need to master this challenge. What secrets will you discover? What obstacles will you outsmart?`;
      
      case 'practice':
        return `üéØ Power up your skills! Train like a champion through fun exercises and exciting challenges. Build your confidence and become unstoppable!`;
      
      case 'apply':
        return `‚ö° Time to shine! Put your amazing knowledge to work and solve real problems like a true hero. Show the world what you can accomplish!`;
      
      case 'reflect':
        return `üåü Celebrate your incredible journey! Look back at all the awesome things you've learned and achieved. What made you feel like a superstar? What would you do even better next time?`;
      
      case 'present':
        return `üì¢ Share your greatness with the world! Show off your amazing creations and inspire others with your incredible discoveries and insights!`;
      
      default:
        return `üöÄ Get ready for an amazing ${adventureTitle} experience that will blow your mind and make learning the best part of your day!`;
    }
  }

  /**
   * Mark an adventure as completed
   */
  static async completeAdventure(
    studentId: string, 
    universeId: string, 
    isRecap: boolean = false, 
    performanceScore?: number
  ): Promise<void> {
    const { error } = await supabase
      .from('student_adventures')
      .insert({
        student_id: studentId,
        universe_id: universeId,
        is_recap: isRecap,
        performance_score: performanceScore
      });

    if (error) {
      console.error('Error completing adventure:', error);
      throw error;
    }
  }

  /**
   * Get student's adventure history
   */
  static async getAdventureHistory(studentId: string): Promise<AdventureProgress[]> {
    const { data, error } = await supabase
      .from('student_adventures')
      .select('*')
      .eq('student_id', studentId)
      .order('completed_at', { ascending: false });

    if (error) {
      throw error;
    }

    return data.map(item => ({
      ...item,
      completed_at: new Date(item.completed_at)
    })) as AdventureProgress[];
  }

  /**
   * Get adventure statistics
   */
  static async getAdventureStats(studentId: string): Promise<{
    totalCompleted: number;
    totalRecaps: number;
    averageScore: number;
    streak: number;
  }> {
    const { data } = await supabase
      .from('student_adventures')
      .select('performance_score, is_recap, completed_at')
      .eq('student_id', studentId)
      .order('completed_at', { ascending: false });

    if (!data) {
      return { totalCompleted: 0, totalRecaps: 0, averageScore: 0, streak: 0 };
    }

    const totalCompleted = data.filter(a => !a.is_recap).length;
    const totalRecaps = data.filter(a => a.is_recap).length;
    const scoresWithData = data.filter(a => a.performance_score !== null);
    const averageScore = scoresWithData.length > 0 
      ? scoresWithData.reduce((sum, a) => sum + (a.performance_score || 0), 0) / scoresWithData.length
      : 0;

    // Calculate streak (consecutive days with adventures)
    // TODO: Implement proper streak calculation based on dates
    const streak = data.length; // Simplified for now

    return {
      totalCompleted,
      totalRecaps,
      averageScore: Math.round(averageScore),
      streak
    };
  }
}